//
//  Image360Controller.swift
//  Image360
//


import UIKit

private let blackFileURL = Bundle(for: Image360Controller.self).url(forResource: "black", withExtension: "jpg")!

/// ## Image360Controller
/// This controller presentes a special view to dysplay 360° panoramic image.
public class Image360Controller: UIViewController {
    /// Image 360 view which actually dysplays 360° panoramic image.
    public var imageView: Image360View
    /// Special OpenGL controller to ouput Image360View
    private let image360GLController: Image360GLController
    /// Displays current camera position.
    private var orientationView: OrientationView

    // MARK: Inertia
    private let inertiaInterval: TimeInterval = 0.020
    /// Amount of movement parameter for inertia (weak)
    private let weakIntertiaRatio: Float = 1.0
    /// Amount of movement parameter for inertia (strong)
    private let strongIntertiaRatio: Float = 10.0

    private var inertiaRatio: Float?

    /// Inertia of pan gestures. In case inertia is enabled (not equal to .none)
    /// view of **Image360Controller** continue to rotate after pan gestures for some time.
    public var inertia: Inertia = .short {
        willSet {
            inertiaTimer?.invalidate()
            inertiaTimer = nil
            inertiaTimerCount = 0
        }
    }

    fileprivate var inertiaTimerCount: UInt = 0
    fileprivate var inertiaTimer: Timer?

    /// Image presented in controller at the moment. Image need to be captured by special
    /// 360° panoramic camera or generated by special software.
    public var image: UIImage? {
        get {
            return imageView.image
        }
        set {
            imageView.image = newValue
        }
    }
    
    /// Set this flag `true` to hide orientation view.
    public var isOrientationViewHidden: Bool {
        get {
            return orientationView.isHidden
        }
        set {
            orientationView.isHidden = newValue
        }
    }

    public required init?(coder aDecoder: NSCoder) {
        imageView = Image360View(frame: CGRect(x: 0, y: 0, width: 512, height: 512))
        image360GLController = Image360GLController(imageView: imageView)
        let orientationView = OrientationView(frame: CGRect(x: 0.0, y: 0.0, width: 30.0, height: 30.0))
        orientationView.backgroundColor = UIColor(white: 0.5, alpha: 0.5)
        orientationView.tintColor = .white
        self.orientationView = orientationView
        super.init(coder: aDecoder)
        registerGestureRecognizers()
        imageView.touchesHandler = self
        imageView.orientationView = orientationView
        
        setBlackBackground()
    }

    public override func loadView() {
        super.loadView()
        addChildViewController(image360GLController)
        view.addSubview(imageView)
        image360GLController.view.frame = view.bounds
        image360GLController.view.autoresizingMask = [.flexibleWidth,.flexibleHeight]
        image360GLController.didMove(toParentViewController: self)
        
        view.addSubview(orientationView)
        orientationView.frame = CGRect(origin: CGPoint(x: view.bounds.maxX - orientationView.frame.size.width - 8,
                                                       y: view.bounds.midY - orientationView.bounds.midY),
                                       size: orientationView.frame.size)
        orientationView.autoresizingMask =  [.flexibleTopMargin, .flexibleBottomMargin, .flexibleLeftMargin]
    }

    // MARK: Appear/Disappear
    private var isAppear = false

    public override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        if let presentedImage = imageView.image {
            imageView.image = presentedImage
        }
    }

    public override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        isAppear = true
    }

    public override func viewDidDisappear(_ animated: Bool) {
        imageView.unloadTextures()

        super.viewDidDisappear(animated)
        isAppear = false
    }

    // MARK: Helpers
    private func setBlackBackground() {
        let data = (try? Data(contentsOf: blackFileURL))!
        let image = UIImage(data: data)!
        imageView.image = image
    }

    // MARK: Gestures
    private var panGestureRecognizer: UIPanGestureRecognizer!
    private var pinchGestureRecognizer: UIPinchGestureRecognizer!

    fileprivate var isPanning = false
    private var panPrev: CGPoint?
    private var panLastDiffX: CGFloat?
    private var panLastDiffY: CGFloat?

    /// Gesture registration method
    private func registerGestureRecognizers() {
        panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(panGestureHandler(recognizer:)))
        panGestureRecognizer.maximumNumberOfTouches = 1
        panGestureRecognizer.delegate = self
        imageView.addGestureRecognizer(panGestureRecognizer)

        pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(pinchGestureHandler(recognizer:)))
        pinchGestureRecognizer.delegate = self
        imageView.addGestureRecognizer(pinchGestureRecognizer)
    }


    /// Pinch operation compatibility handler
    /// - parameter recognizer: Recognizer object for gesture operations
    func pinchGestureHandler(recognizer: UIPinchGestureRecognizer) {
        switch recognizer.state {
        case .began:
            prevScale = 1.0
        default:
            ()
        }
        scale(ratio: recognizer.scale)
    }

    /// Pan operation compatibility handler
    /// - parameter recognizer: Recognizer object for gesture operations
    func panGestureHandler(recognizer: UIPanGestureRecognizer) {
        let cur = recognizer.translation(in: imageView)

        switch recognizer.state {
        case .ended:
            inertiaTimer?.invalidate()
            inertiaTimerCount = 0

            if inertia != .none {
                inertiaTimer = Timer.scheduledTimer(timeInterval: inertiaInterval,
                                                    target: self,
                                                    selector: #selector(inertiaTimerHandler(timer:)),
                                                    userInfo: nil,
                                                    repeats: true)
            }
        default:
            if isPanning {
                panLastDiffX = cur.x - panPrev!.x
                panLastDiffY = cur.y - panPrev!.y

                panPrev = cur
                rotate(diffx: -Float(panLastDiffX!), diffy: Float(panLastDiffY!))
            } else {
                isPanning = true
                panPrev = cur
            }
        }
    }

    /// Timer setting method
    /// - parameter timer: Setting target timer
    func inertiaTimerHandler(timer: Timer) {
        var diffX: Float = 0
        var diffY: Float = 0

        if inertiaTimerCount == 0 {
            inertiaRatio = 1.0
            switch inertia {
            case .short:
                inertiaRatio = weakIntertiaRatio
            case .long:
                inertiaRatio = strongIntertiaRatio
            case .none:
                ()
            }
        } else if inertiaTimerCount > 150 {
            inertiaTimer?.invalidate()
            inertiaTimer = nil
            inertiaTimerCount = 0
        } else {
            diffX = Float(panLastDiffX!) * (1.0 / Float(inertiaTimerCount)) * inertiaRatio!
            diffY = Float(panLastDiffY!) * (1.0 / Float(inertiaTimerCount)) * inertiaRatio!

            rotate(diffx: -diffX, diffy: diffY)
        }

        inertiaTimerCount += 1
    }

    // MARK: Scaling & rotation
    private var prevScale: CGFloat = 1.0
    /// Parameter for maximum width control
    private let scaleRatioTickExpansion: Float = 1.05
    /// Parameter for minimum width control
    private let scaleRatioTickReduction: Float = 0.95

    /// Zoom in/Zoom out method
    /// - parameter ratio: Zoom in/zoom out ratio
    private func scale(ratio: CGFloat) {
        if ratio < prevScale {
            imageView.setCameraFovDegree(newValue: imageView.cameraFovDegree * scaleRatioTickExpansion)
        } else {
            imageView.setCameraFovDegree(newValue: imageView.cameraFovDegree * scaleRatioTickReduction)
        }
        prevScale = ratio
    }

    /// Parameter for amount of rotation control (X axis)
    private let divideRotateX: Float = 500.0
    /// Parameter for amount of rotation control (Y axis)
    private let divideRotateY: Float = 500.0

    /// Rotation method
    /// - parameter diffx: Rotation amount (y axis)
    /// - parameter diffy: Rotation amount (xy plane)
    func rotate(diffx: Float, diffy: Float) {
        let xz = diffx / divideRotateX
        let y = diffy / divideRotateY

        imageView.setRotationAngleXZ(newValue: imageView.rotationAngleXZ + xz)
        imageView.setRotationAngleY(newValue: imageView.rotationAngleY + y)
    }
}

// MARK: - UIGestureRecognizerDelegate
extension Image360Controller: UIGestureRecognizerDelegate {
    // UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:) handler.
    public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return false
    }
}

// MARK: - Image360ViewTouchesHandler
extension Image360Controller: Image360ViewTouchesHandler {
    func image360View(_ view: Image360View, touchesBegan touches: Set<UITouch>, with event: UIEvent?) {
        inertiaTimer?.invalidate()
        inertiaTimer = nil
        inertiaTimerCount = 0

        isPanning = false
    }

    func image360View(_ view: Image360View, touchesMoved touches: Set<UITouch>, with event: UIEvent?) {
    }

    func image360View(_ view: Image360View, touchesEnded touches: Set<UITouch>, with event: UIEvent?) {
    }
}
